For task four, an RSA algorithm was created in Python 6.2.1 on the online compiler repl.it. The program does not have input checkers and so if a wrong input is entered after the prime checker loop the program will need to be restarted to get the same output as the user inputs.

The program begins with a prime checker, the user enters a number and the program tells the user if it is prime or not, if it is prime they should input “n” to continue to the next section where their input will become “P” if its “a” and “Q” if its “b”. If the number is not prime, the program will let the user know and tell them to press “y” to reuse the program. There is a list at the top of the actual program with a list of acceptable primes.

In the RSA cipher, there are two people. Person A chooses two primes; these primes are P and Q. P and Q are used to calculate N and Z and from there P and Q become obsolete. N will be a public key and so will E. E is found by several steps. First by multiplying Z by a random number between 2 and 100, and then adding one to that. Then by taking that number- let’s call it K; and producing a list of its factors and choosing a random one. This number is variable “E”. 

K is divided by E using floor division, which will return an integer. This integer is the private key: D, which will not be shared with person B. N and E are sent by person A to person B, person B then writes a message and changes it to ASCII code. The message is variable “M”. M, N and E are then entered the equation M^E mod N to encrypt the message. This is then sent from person B to person A. The decrypted message is “e”.

Person A receives the message, and is aware that ASCII code was used. Using public key N and private key D, inputted in the equation: e^D mod N the message is decrypted. The message is then changed back from ASCII to plaintext and as it will be in a list it will need to be converted from a list to a string to show the exact message that was sent by Person B.
