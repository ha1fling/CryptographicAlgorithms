This task encompassed the creation of a cipher block chain to encrypt and to decrypt a hexadecimal message using Python 3.5.2 on an online compiler repl. The code created encrypts the cipher block chain, however does not decrypt it. With more time and more prior programming knowledge the task could be completed, however under the circumstances it was not possible.

A cipher block chain works at the bit level. A hexadecimal key and a hexadecimal message is entered, in this code, that will be done using prompts. Both the key and the message are converted to decimal. 

The code written, needs editing if the user wishes to use a certain digit input, the example code is for a five-digit hexadecimal message, however can be edited to work for multiple inputs. To edit the code to do so see the orange code in the table, there are also notes on what could be done to automate the process, which there was not time to figure out. 

This for loop uses “j”, however any letter could be used. It states it should be looped [1,2,3,4,5] times, it reads like this as this was the way found to see a result at the end of each loop, to check the results working outs were being done on paper so being able to see this was important. This is also why so much is converted to binary when it need not be to get the final loop’s result. The hex string that was entered is now converted to a list and the code “o=m[p:q]” is used to ‘cut’ a four bit block from it. For the first loop “p” is zero and “q” is four. At the end of the loop there is code to show that p should be increased by four in each loop and so should q. This way each loop chooses the next four-bit block. The first block is converted from a list to a string format and converted from binary to decimal. 

Now there is a four-bit decimal “block” defined as an integer M, and a decimal key defined as the integer K it is possible to continue to the next stage. Using the syntax: `XOR=(int(a)^int(b))` two XORs are computed, the first is an XOR of “M” and “C”. C is an integer that is set to zero outside of the loop (at the top of the code) and so for the first loop this outputs “M” with no change. Doing this on paper, you could completely skip this step for the first loop. For the loops that come after the first C will be the outcome of the predeceasing loop and will be rewritten each loop. The next XOR is the outcome of the first XOR which I call “XORC” with the key: K. The outcome will need to be converted back to binary from decimal and from a string to a list for the next stage: The rotation. 

A recursive for loop is used to rotate the numbers once to the left. The range is the length of the list and the if and else conditions check whether the digit ‘moving’ from the one side to the other is a one or a zero. The “-1” in the syntax: rotate(Rotate, -1) shows that the rotation will be done once to the left. If this was “1” it would be one to the right, which could be assumed to be used for the decryption process. Also, this code can rotate more than once either way and so if “2” was used, the bits would be rotated twice to the right, for example: 1101 would become- 0111. 

The binary list would be converted back into a decimal string, and this will become C to be used for the next loop, and that is the end of the first loop.
